//map方法
const map = new Map([
        ["a",1],
        ["b",2]
    ]);
console.log(map.size);
map.set("miaov","ketang").set("new","fq").set("new","xin");
console.log(map);//链式操作，后面覆盖前面
console.log(map.get("new"));
console.log(map.delete("miaov"));//删除键值对
console.log(map.delete("miaov"));//false
console.log(map.has("miaov"));//false
console.log(map.has("new"));//true
//map.clear();//清除所有数据
console.log(map.keys());
console.log(map.values());
console.log(map.entries())//返回键值对的遍历器
map.forEach(function(key,value,map){
    console.log(key+":"+value);
})
//注意点
map.set(NaN,10).set(NaN,100);//添加了最后一个，NaN是一个键
map.set({},"x").set({},"y");//两个都添加
console.log({} === {});//false 引用数据类型
//map里面的key的排列顺序是按照添加顺序进行排列的


//Object.defineProperty(obj, prop, descriptor)

//for...in 遍历当前对象以及原型链上所有可枚举的属性
//for...of 根据迭代对象的迭代器具体实现迭代对象数据

var obj = {x:1};
Object.prototype.xx = 100;
Object.defineProperty(Object.prototype,"xy",{
    // configurable:是否可改变 false
    // enumerable true时该属性才能够出现在对象的枚举属性中 false
    // writable 当且仅当该属性的writable为true时，value才能被赋值运算符改变 false
    value:100,
    enumerable:false
})
for(let attr in obj){
    console.log(attr);
    //x xx  enumerable:false
    //x xx xy  enumerable:true
}
 
let arr = ["a","b","c","d","a","b"];
arr = [...new Set(arr)];
console.log(arr);//["a", "b", "c", "d"]

for in是ES5标准，遍历key. 
for of是ES6标准，遍历value.

for (var key in arr){
    console.log(arr[key]);
}

for (var value of arr){
    console.log(value);
}
 


Object.prototype.objCustom = function () {}; 
Array.prototype.arrCustom = function () {};

let iterable = [3, 5, 7];
iterable.foo = "hello";

for (let i in iterable) {
  console.log(i); //  0, 1, 2, "foo", "arrCustom", "objCustom"
}

for (let i of iterable) {
  console.log(i); // 3, 5, 7
}


暂时性死区：
let f = 10;
function fn(){
    f = 7;
    let f = 2;
}
fn();


解构赋值：
let {a:b} = {a:1};
console.log(b);//1
console.log(a);//a is not defined
原因：a是属性名，b是变量名


基本类型的解构赋值：
lat [a,b,c,d] = '1234';
console.log(a,b,c,d);//1 2 3 4

let {length:len} = "guokun";
console.log(len);//6

let {toString:ts} = 1;
let {toString:bs} = true;
console.log(ts === Number.prototype.toString);//true
console.log(ts === Boolean.prototype.toString);//true


set:（没有重复数据）
const s = new Set([1,2,3]);
console.log(s);//Set(3) {1,2,3}
console.log(s.size);//3
s.add("a").add("b").add("c");
console.log(s);//Set(6) {1,2,3,"a","b","c"}
console.log(s.delete("a"));//true
console.log(s);//Set(5) {1,2,3,"b","c"}
console.log(s.delete("a"));//false
console.log(s.has("a"));//false
console.log(s.has(1));//true
console.log(s.keys());//返回键名
console.log(s.values());
console.log(s.entries());
s.forEach(function(value,lkey,set){
    console.log(value + "郭坤");
})
console.log(s);//原值没有发生改变
s.clear();
console.log(s);//Set(0){}


class的使用：
class gk{
    constructor(a,b){
        this.a = a;
        this.b = b;
        return this;
    }
    print(){
        console.log(this.a + "---" + this.b)
    }
}
const classDemo = new gk("name","guokun").print();//name---guokun
