第一种方法也是最简单的方法，使用call或apply方法，讲父对象的构造函数绑定在子对象上，即在子对象构造函数中加一行
function Cat(name,color){
    Animal.call(this);
    this.name = name;
    this.color = color;
}
var cat1 = new Cat("大毛","黄色");
alert(cat1.species);


第二种方法使用prototype属性
如果“猫”的prototype对象，指向一个Animal的实例，那么所有“猫”的实例，就能继承Animal
Cat.prototype = new Animal();
Cat.prototype.constructor = Cat;
var cat1 = new Cat("大毛","黄色");
alert(cat1.species);//动物
将Cat的prototyp对象指向一个Animal的实例
注意：会删除原来prototype的值
prototype对象都有一个constructor属性，指向它的构造函数
每一个实例也有一个constructor属性，默认调用prototype对象的constructor属性


第三种方法是对第二种方法的改进，由于Animal对象中，不变的属性都可以直接写法Animal.prototype，所以，我们也可以让Cat()跳过Animal(),直接集成Animal.prototype
Cat.prototype = Animal.prototype;
Cat.prototype.constructor = Cat;
var cat1 = new Cat("大毛","黄色");
alert(cat1.species);//动物
与前一种方法相比，这样做的优点是效率比较高（不用执行也简历Animal的实例了），比较省内存。缺点是Cat.prototype和Animal.prototype现在指向了同一个对象，那么任何对Cat.prototype的修改，都会反映到Animal.prototype


第四种方法，利用一个空对象作为中介
var F = function(){};
F.prototype = Animal.prototype;
Cat.prototype = new F();
Cat.prototype.constructor = Cat;
F是空对象，所以几乎不占内存，这时，修改Cat的prototype对象，就不会影响到Animal的prototype对象


第五种拷贝集成
function extend(Child,Parent){
    var p = Parent.prototype;
    var c = Child.prototype;
    for(var i in p){
        c[i] = p[i];
    }
}