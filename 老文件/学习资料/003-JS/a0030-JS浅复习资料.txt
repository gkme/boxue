JS引入方式：外链 内嵌 行内
内嵌: <script></script>
行内：<div onclick="alert(1)"></div>
外链：<script src="相对路径"></script>
JS在文件中的位置:head标签里面 可以放在body任何一个位置{推荐body结束标签之前}
js是基于对象的语言{js里面内置了很多的对象}
事件驱动：鼠标事件 键盘事件
并具有安全性能：js不允许查看硬盘上的文件
特性:脚本语言 基于对象 简单 动态性 跨平台性
不同于服务器端脚本语言,是一种解释型的脚本语言,是在程序运行过程中逐行运行
优点：节省服务器端的资源;仅在客户端就可运行不需要服务器和网络参与
单行注释 ctrl + /
多行注释 ctrl + shift +/
JS严格区分大小写
定义变量时直接使用var,不需要指定数据类型,所以称之为弱类型语言

JS的五种输入方式：
alert(); 警示框
console.log();
prompt(); 接收用户输入的信息,点击确定返回用户输入的内容;取消 null;
confirm(); 确定取消按钮 确定true取消返回的是false
document.write();直接显示在浏览器上
如果在文档加载结束以后再执行会覆盖文档原有内容

JS原始数据类型{基本数据类型}
number 数字 
字符串 使用双引号或者单引号引起来的内容
boolean 布尔值 true和false
null 只有一个值null
undefined 只有一个值undefined{定义了变脸没有赋值}

=:赋值运算符 右侧内容赋值给左侧变量
常量:字面值 变量:可以发生变化的量,名字不要重复
Infinity 最大值
命名规范:(1)只能是数字,字母,_,$不能以数字开头
(2)变量不能使用关键字和保留字
(3)要求变量名“望文知意”
(4)变量的名字尽可能简短,推荐使用驼峰格式

基本数据类型和引用数据类型:在内存里面存储的位置不同
基本数据类型是存放在栈里面,引用的放在堆里面
所有的变量名都存放在栈里面,栈的读取速度比堆快
==:比较运算符 用来比较左右两侧值是否相等
如果相等返回true否则false
undefined和null的区别:
都表示空;但是undefined是有声明但是未赋值,null表示内存根本不存在
NaN:not a numer 不是数字
isNaN:如果不是数字返回true是数字返回false
类型转换:转换为字符串:任何的数据类型都可以转换为字符串
+:任何的数据类型跟字符串做+运算,结果都是字符串
toString(); 任何的数据类型都可以调用toString方法转换为字符串
但是undefined和null会报错,未定义的会报错
console.log(num.toString(2));转为二进制的字符串,默认是十进制
number类型转换:浮点数(小数)和整数
parseFloat:转换为浮点数
parseInt:转换为整数
浮点数在计算机中存储的是不确定的值,所以不要使用浮点数的比较

parseInt不会四舍五入;console.log(parseInt(10.9));-->10
从左侧开始查看第一个位置的内容,如果是数字则继续第二个
以此类推,直到非数字的内容停止,取前面的数字
如果是两个参数,第二个参数是基数：
console.log(parseInt("10",2)); 2表示二进制
bollean类型会被转换为NaN
如果第一个字符是非法字符,返回NaN

parseFloat();参数只能是十进制;如果第一个字符是非法字符,返回NaN;
布尔类型,null，undefined会被转换为NaN
强制类型转换:转换为字符串,转换为boolean,转换为数字
转转为字符串:+ toString String
String:(1)boolean,null,NaN,undefined都是直接转换为字符串类型,不会报错
(2)数字也是直接转换为字符串
JS中的6个假值:{在做类型转换时可以转换为false的值就是假值}
0,"",null,false,NaN,undefined
转换为boolean Boolean();
(1)除了0意外的数字转换为true,0转为false
(2)sring:空的字符串转换为false,其余的为true
转换为数字 Number()
(1)字符串:如果整体可以转换为数字,根据情况去调用pardeInt或者parseFloat
如果含有特殊字符直接转换为NaN
(2)boolean类型 true会返回1,false返回0
(3)空字符串
console.log(Number(true));//1
console.log(Number(false));//0
console.log(Number(null));//0
console.log(Number(undefined));//NaN
console.log(Number(NaN));//NaN
console.log(Number(0));//0

==运算符:数学运算,关系运算,逻辑运算,位运算
1.数学运算:+-*/ %{取余数/取模}
(1)+运算:如果跟字符串做运算就是字符串的拼接
都是数字则直接试数学的加法
(2)-运算:就是数字相减
会将字符串,boolean使用Number方法转换为number类型
在实际开发中自己主动去转,尽量不要用系统去转
(3)console.log(10%3); 1
console.log(5%6); 5
(4)++i前增量 后增量i++ = i+1
(4)--i前减量 后减量i-- = i-1
2.比较运算符:
  ==,===,<,>,<=,>=,!={不等于},!=={不全等于}
 var str = "120",str1 = "21";
 console.log(str>str1); flase
 比较首位的ASCII码
 (1)字符串和数字作比较,将字符串转换为number类型
 如不能转返回false;能转就比较数字大小
 (2)字符串和字符串作比较直接比较ASCII码
 ==只是比较内容
 ===同时比较内容和数据类型(true/false)
3.逻辑运算符：&& || ! 与或非
返回的是boolean类型
(1)值1&&值2 只有都为true结果才是true
短路:值1为flase直接返回false不再执行值2
(2)|| 只有都为false结果才是false
短路:值1为true,直接返回true,不再执行值2
(3)！ 取反的概念
执行顺序:
数学>比较>逻辑>赋值

==语句
1.条件表达式{三目运算符,三元运算符} 
表达式?值1:值2
var level=score>=90?"值1":"值2";
2.if..else
(1)if(boolean值或者boolean类型表达式){}
6个假值不运行,返回值true才运行下面的代码块
(2)if(js语句)else if{语句} else if可以有多个
3.开关语句 switch语句(判断语句 多分支语句)
switch (expression) {
case value: statement;
 break;
case value: statement;
 break;
...
case value: statement;
 break;
default: statement;
}
关键字 break 会使代码跳出 switch 语句。如果没有关键字 break，代码执行就会继续进入下一个 case。
关键字default说明了表达式的结果不等于任何一种情况时的操作（事实上，它相当于 else 从句）
4.for(初始值;结束条件;步长或增量){}
先执行初始值,仅仅执行一次
判断条件,true则执行js语句 执行后执行增量
循环执行至结束条件
for(var i=0;i<10;i++) JS语句块结束 i=10
5.双重for循环
6.while循环 while(){}
7.do{JS语句}while(条件)
不管判断条件成立不成立,js语句至少会执行一次
break：跳出循环
continue：跳过本次循环继续下次循环
面试题:什么情况系下回打印出OK
if(flag){alert("ok")}; 
flag不等于0,false,"",null,undefind,NaN
for-in: for(变量 in 对象)
for(var j in arr){}

==函数:是一段代码块,用来完成某些功能{提高代码的复用}
注:函数不调用不会执行 
函数不管定义在哪个地方,默认是在调用之前
{所以调用可以在任何位置,即使在定义之前}
函数表达式：调用必须在赋值以后
函数重名以最后一个为准
函数分形参(函数定义时的参数)和实参(调用时传递的参数)
形参和实参个数不一致：
(1)形参多于实参:多余的形参是undefined
(2)实参多于形参:多余的实参忽略
参数是引用数据类型,传递的是地址{传址}
参数是基本数据类型,传递的是数值{传值}
函数分为有返回值的函数和无返回值的函数：
使用return像外部传递数据,内容可以是任何数据类型
注意:return 下面的代码块不会执行
全局变量和局部变量：
全局变量:定义在函数体外面的变量
作用域:在整个JS代码块里都起作用,在函数体里面也可以访问全局变量
局部变量:定义在函数体内部的变量{包括形参}
作用域:只在函数体内部起作用,函数体碗面不能访问局部变量
JS中变量的声明被提前到使用之前,但赋值被保留在原位置
递归:是一种思想,满足两个条件:有结束条件;自己调用自己
斐波那契数列：1 1 2 3 5 8 13 21 34...求第n项
function fbo(n){
 if(n==1||n==2){
 return 1;
 }else{
 return fbo(n-1)+fbo(n-2);
 }
}

var str="abcd"; alert(str[3]); -->d
字符串引号和字符串中引号不相同：\
  转移字符:只是字符,没有特殊含义 varstr="小明说:\"你好"";
  主要用于alert弹窗 换行 引号等特殊字符
对象的属性和方法:方法调用加() 属性不需要
ASCII:0-9 --> 48-57 A-Z --> 65-90 a-z -->97-122 回车13 方向键左上右下37 38 39 40
==================字符串
charAt()返回指定索引位置的字符
charCodeAt()返回指定索引位置字符的 ASCII码
concat()连接两个或多个字符串，返回连接后的字符串
fromCharCode()将ASCII码转换为字符串
indexOf()返回字符串中指定字符串第一次出现的位置
lastIndexOf()返回字符串中指定字符串最后一次出现的位置
localeCompare()用本地特定的顺序来比较两个字符串 //out 1{大小},0{相等},-1{小大}
match() 找到一个或多个正则表达式的匹配  //以后讲到正则再讲
replace()替换与正则表达式匹配的子串
search()检索与正则表达式相匹配的值 //以后讲到正则再讲
substring()提取字符串中两个指定的索引号之间的字符
slice()提取字符串的片断，并在新的字符串中返回被提取的部分 
//主要跟substring做下区分，一个初始值可以为负值，一个不可以
slice(开始,结束){包含,不包含,负数从最后向前1,2,3..}
substr()substr(起始位,长度)
split()把字符串分割为子字符串数组
toLowerCase()把字符串转换为小写 ()无参数
toUpperCase()把字符串转换为大写 ()无参数
toString()返回字符串对象值
trim()移除字符串首尾空白 {不支持ie78}

定时器和for语句的区别:setInterval("fun()",1000); console.log("end");
这里会异步 先执行打印再执行定时器里面的JS语句

========================数组
concat()连接两个或更多的数组，并返回结果{不影响原数组内的元素}
indexOf()搜索数组中的元素，并返回它所在的位置{有1无-1返回第1个匹配的位置}
join()把数组的所有元素放入一个字符串
lastIndexOf()返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。
pop()删除数组的最后一个元素并返回删除的元素。
shift()删除并返回数组的第一个元素。
push()向数组的末尾添加一个或更多元素，并返回新的长度。
reverse()反转数组的元素顺序。
slice()选取数组的一部分，并返回一个新数组。
sort()对数组的元素进行排序 括号内无参数
toString()把数组转换为字符串，并返回结果。
unshift()向数组的开头添加一个或更多元素，并返回新的长度。
valueOf()返回数组对象的原始值。
splice()从数组中添加或删除元素
arr.splice(2,1,"6");删除从第2位开始的1位并添加上6
arr.splice(2,2)删除从第2位开始的2位
arr.splice(2,0,6,6); 0代表添加从第二位添加6 6

创建数组三种方式：
(1)var names = new Array();
    names[0] = "a";
    names[1] = 8;
    names[3] = true;
   console.log(names); 空数组
(2)var names = "alice,john,apple,beef";
   var username = new Array("alice",3,true,"beef");
      console.log(username[2]); 直接赋值
(3)var names = ["alice",8,true]; 字面辆数组{new Array被隐性使用}
typeof x 判断类型
x instanceof y 判断指定实例化对象是否是某个对象的实例结果返回布尔值
DOM对象的innerHTML属性用来读写双标签元素的内容(单标签没有内容)

创建新方法
Array.prototype.ucase=function(){
for (i=0;i<this.length;i++) {
this[i]=this[i].toUpperCase();
}
}
全局作用域中的this(原生就有this)指向window对象
事件处理中的this指向触发该事件的元素
谁调用谁是this,不同的调用内部的this指向也不同
生成开始--结束之间的随机数：
console.log(Math.floor(Math.random()))*((end-start+1)+start);
设置或获取CSS样式:obj.style.color  css样式的值一定是字符串
获取样式(只能是行内样式)console.log(ball.style.left)
设置样式 ball.style.fontSize="30px"; S大写 -去掉

=========================MATH
PI返回圆周率（约等于3.14159）。
abs(x)返回数的绝对值。
ceil(x)对数进行上舍入。
cos(x)返回数的余弦。
floor(x)对数进行下舍入。
max(x,y)返回 x 和 y 中的最高值。
random()返回 0 ~ 1 之间的随机数。(重点)
round(x)把数四舍五入为最接近的整数。

//Date对象:
1.  var d = new Date(); //**没有参数的话，返回当前时间** 
getFullYear()从 Date 对象以四位数字返回年份。
getYear()从 Date 对象以四位数字返回年份，相对于1900年的年份，用处不大。
getMonth()从 Date 对象返回月份 (0 ~ 11)，0代表1月。
getDate()从 Date 对象返回一个月中的某一天 (1 ~ 31)。
*getDay()从 Date 对象返回一周中的某一天 (0 ~ 6)，0代表星期日。
getHours()返回 Date 对象的小时 (0 ~ 23)。时间方法名中都有s
getMinutes()返回 Date 对象的分钟 (0 ~ 59)。
getSeconds()返回 Date 对象的秒数 (0 ~ 59)。
getMilliseconds()返回 Date 对象的毫秒(0 ~ 999)。
getTime()返回 1970 年 1 月 1 日至今的毫秒数。
setFullYear()设置 Date 对象中的年份（四位数字）。
setYear()请使用 setFullYear() 方法代替。
setMonth()设置 Date 对象中月份 (0 ~ 11)。
setDate()设置 Date 对象中月的某一天 (1 ~ 31)。 setDate(0)获取上月最后一天
setHours()设置 Date 对象中的小时 (0 ~ 23)。
setMinutes()设置 Date 对象中的分钟 (0 ~ 59)。
setSeconds()设置 Date 对象中的秒钟 (0 ~ 59)。
setMilliseconds()设置 Date 对象中的毫秒 (0 ~ 999)。
setTime()以毫秒设置 Date 对象。
toString()把 Date 对象转换为字符串。
toTimeString()把 Date 对象的时间部分转换为字符串。
toDateString()把 Date 对象的日期部分转换为字符串。

== setIterval(show,1000); 通用函数体外、内部都可以用
setInterval("show()",1000);只能在函数体外调用
setTimeout和setIterval所调用的this指向window
函数和函数表达式区别:函数调用可以在函数定义之前
BOM计数器：
setTimeout() 指定的毫秒数之后执行指定的代码{仅执行一次}
setInterval() 间隔指定的毫秒数不停地执行指定的代码
clearTimeout() 用于停止执行setTimeout()方法的函数代码。
clearInterval() 用于停止 setInterval() 方法执行的函数代码

//冒泡排序
var bubblesort=function(arr){
for(var i=0;i<arr.length-1;i++){
for(var j=0;j<arr.length;j++){
if(arr[i]>arr[j]){
var temp=arr[i];
arr[i]=arr[j];
arr[j]=temp;
}
}
}
return arr;
}
var arr=[9,8,7,6,5,4,3,2,1];
console.log(bubblesort(arr));

//打印2--100之间的素数
var arr=[];
for(var i=2;i<100;i++){
var flag=true;
for(var j=2;j<=i/2;j++){
if(i%j==0){
flag=false;
break;
}
if(flag=true){
arr.push(i);
}
}
}
console.log(arr);

==DOM对象操作
API:(应用程序编程接口)是一些预先定义的函数
1.通过id查找HTNL元素(未找到-->null)
2.通过标签名(获取的是存储dom的数组)
3.通过name属性(只针对表单元素)(得到的是数组)
4.通过类名(IE78无效)
5.document.querySelector();
   它可以通过id,标签，类名来获取dom;
仅仅返回匹配指定选择器的第一个元素。如果你需要返回所有的元素，请使用 querySelectorAll() 方法替代。
浏览器支持：  IE 8.0   chrome:4.0    FF: 3.5 
例：
document.querySelector("p"); 
document.querySelector(".example"); 
document.querySelector(“p.example”);  //获取标签为p,并且类名为example的元素
document.querySelector(“a[target]”); //获取标签为a,并且有target属性的元素
document.querySelector(“h2, h3”) // 获取标签为h2和h3的元素

绝不要在文档加载之后使用 document.write()。这会覆盖该文档
修改 HTML 内容的最简单的方法时使用 innerHTML 属性。obj.innerHTML="";
改变html属性：
1. obj. 属性=新值
2.  Obj. setAttribute("type","button");    //添加、更改属性
  注释：Internet Explorer 8 以及更早的版本不支持此方法。 
3. Obj .getAttribute(属性名)//返回指定属性名的属性值 
改变 HTML 元素的样式
访问行内样式：obj.style.CSS样式名=新值
访问元素类名：obj.className = "类名"
// 修改、添加、删除类名、去掉一个类名
//添加时前面应该有个空格 " active"
获取元素最终CSS样式的方法：
a、obj.currentStyle[attr]:
{attr：样式}兼容IE，获取元素最终样式（内部、外部样式最后的效果），只读
b、window.getComputedStyle(obj , null)[attr]; 兼容FF，chrome,safiri，只读
在兼容浏览器返回[object],不兼容undefined
可通过该属性判断浏览器类型
获取元素最终样式的兼容代码：
window.onload=function(){
    var cont=document.getElementById("cont");
        // alert(cont.currentStyle);
        if (cont.currentStyle){
            alert("height:"+cont.currentStyle["height"]);
        }else{
            alert("height:"+getComputedStyle(cont,null)["height"]);

        }
}

var x=2||5; console.log(x)-->2
var x=0||5; console.log(x)-->5
var x=undefined||5; console.log(x)-->5
如果第一个为真返回第一个值，若假返回第二个值
undefined 0 "" null false NaN

console.log(box.x); -->undedined
对象存在属性值不存在返回undefined
同时绑定多个同样事件,最后一个生效
document.querySelector("h2","h3");
获取标签为h2,h3的标签 谁在上谁生效

==DOM节点操作
1. 整个文档是一个文档节点(document)
2. 每个 HTML 元素是元素节点
3. HTML 元素内的文本是文本节点
4. 每个 HTML 属性是属性节点
5. 注释是注释节点

<html> 节点没有父节点；它是根节点
<head> 和 <body> 的父节点(parentNode)是 <html> 节点
console.log(box.parentNode) 父节点
console.log(box.childNodes) 子节点(数组)
 注:回车和文本算一个节点
insertBefore() :新增子节点，将其插入指定子节点之前。
element.replace(para,oldChild); 替换
parent.removeChild(child) 删除某一个子元素
例如：box.parentNode.removeChild(box);

DOM节点信息包括
1、节点类型（nodeType）
2、节点名称（nodeName）
3、节点值（nodeValue）。
获取节点类型的语法：  
document.getElementById(“id”).nodeType
该属性返回以数字表示的节点类型


元素节点每一个HTML标签都是一个元素节点，如 <div> 、 <p>、<ul>等1
属性节点元素节点（HTML标签）的属性，如 id 、class 、name 等。2
文本节点元素节点或属性节点中的文本内容。3
注释节点表示文档注释，形式为<!-- comment text -->。8
文档节点表示整个文档（DOM 树的根节点，即 document ）9
获取ODM节点：
 获取第一个子节点： nodeObject.firstChild
 获取最后一个子节点： nodeObject.lastChild
 获取子节点集合： nodeObject.childNodes
 获取子节点（元素节点）集合：nodeObject.children
 判断是否存在子节点的方法： hasChildNodes() 
 下一个兄弟节点： nextSibling
 上一个兄弟节点：previousSibling
 父节点：  parentNode
 克隆节点的方法：  cloneNode();

==创建新元素并追加到末尾
var box=document.getElementById("box");
var span=document.createElement("span");
var txt=document.createTextNODE("span内部文字");
span.appendChild(txt);
box.appendChild(span);

<div></div>
<p id="search"></p>
function scb(ids,px){
        window.onscroll = function(){
        var search = document.getElementById(ids);
        var scrollY =  document.body.scrollTop || document.documentElement.scrollTop;
            if (scrollY >= px){
                search.style.display = "block";
            }else{
                search.style.display = "none";
            }
        }
}
    scb("search",300);

==scrollLesft与scrollTop(可读可写,获取数值)
获取或设置页面滚动条滚过的水平距离、垂直距离
clientWidth和clientHeight(只读、数值)(内容+padding)
(不包括边框和滚动条占据的空间)
document。documentElement.clientHeight -->窗口高度(可视见)
offsetWidth与offsetHeight(只读)(内容+padding+border)
**offsetLeft与offsetTop(只读)(左上边界相对有定位的祖先元素左上偏移值)
getBoundingClientRect方法 -->浏览器窗口
(1)得到top right bottom left width(包含边框、内边距) height
(2)right是右边(框)到页面最左边的距离 bottom是底边到页面顶
(3)ie7 8 没有width height属性
(4)ie7 上下左右多2px
e.clientX:鼠标点击时鼠标在浏览器窗口的宽
e.clientY:鼠标点击时鼠标在浏览器窗口的高
e.pagaX:鼠标点击时鼠标在电脑屏幕中的宽
e.pagaY:鼠标点击时鼠标在电脑屏幕中的高

scrollLesft与scrollTop chrome返回0,其它正确
var scrollY;
if(document.body.scrollTop){
scrollY=document.body.scrollTop;
}else{
scrollY=document.documentElement.scrollTOP
}
实例：返回顶部的过渡效果

function getObjXy(obj){
var xy=obj.getBoundClientRect();
var top=xy.top-document.documentElement.clientTop,
bottom=xy.bottom-document.documentElement.clientTop,
left=xy.left-document.documentElement.clientLeft,
right=xy.right-document.documentElement.clientLeft,
width=xy.width||right-left,
height=xy.height||bottom-top;
return{
top:top,
right:right,
bottom:bottom,
left:left,
width:width,
height:height
}
}
var test=getObjXy(document.getElementById("test"));

== box.offsetTop等价于box["offsetTop"]
box.shadow:3px 3px(负值向上) 2px #000;
盒子阴影:水平偏移 垂直偏移 模糊程度 投影颜色
例如: box-shadow:0 0 2px rgba(0,0,0,.2);
cursor:pointer; 变手(光标呈现为指示链接的指针-->一只手)
transition:all 0.5s; 有样式变化0.5秒过渡完成
JSON对象:JS对象表示法 自定义对象(最后一个不加逗号)
var person={
name:"xixi",
say:function(){console.log("this.name")}
}
person.say();

==BOM(浏览器对象模型)
1、window对象(主对象)(顶层对象)
2、navigator对象
3、location对象
4、history对象
5、screen对象
6、document对象

window对象
alert()显示警告框。
setInterval()按照指定的周期（以毫秒计）来调用函数
clearInterval() 取消由setInterval() 的调用
setTimeout() 在指定的毫秒数后调用函数
clearTimeout() 取消由setTimeout() 的调用
prompt()显示可提示用户输入的对话框。
confirm() 显示确认信息框。
close() 关闭浏览器窗口。 

navigator对象
appName返回浏览器的名称。
appVersion返回浏览器的平台和版本信息。
cookieEnabled返回指明浏览器中是否启用 cookie 的布尔值。
onLine返回指明系统是否处于脱机模式的布尔值。
platform返回运行浏览器的操作系统平台。
 !! userAgent返回由客户机发送服务器的 user-agent 头部的值。

location对象
href 设置或返回完整的 URL。(可读可写)
reload() 重新加载当前文档(无参数)(方法)
protocol url地址协议部分
hash(哈希值) 从#开始的url
host 设置或返回主机名和端口号
pathname url的路径部分(域名后/开始)
port url的端口部分
search url的？部分
history对象
 back()加载 history 列表中的前一个 URL。
 forward()加载 history 列表中的下一个 URL。
 go()加载 history 列表中的某个具体页面 -1 1
screen对象 
availHeight返回显示屏幕的高度 (除 Windows 任务栏之外)。
availWidth返回显示屏幕的宽度 (除 Windows 任务栏之外)。
height返回显示屏幕的高度。
width返回显示器屏幕的宽度。

==事件对象(event):
事件源:就是触发事件的元素(不一定是当前对象,可能是其子对象);
FF(火狐)下是target,IE下是srcElement{src是source来源};var box=document.getElementById("box");
box.onclick=function(e){
var e = e || event;
console.log(e.clientY);
}

 srcObj.tagName  获取事件源的大写标签名
注:ie浏览器不传参(传参会报错)直接console.log(event.clientY);
火狐浏览器必须传参{鼠标点击时对应浏览器的高度}
检查键的状态(布尔) event.shiftkey/altkey/ctrlkey
示例: function(e){
var e = e || event;
if(e.srcElement.tagName=="A"&&e.shifthey){
e.returnValue=false;
}
}
鼠标在超链接上时,如果按下shift键就取消链接的跳转
keyCode:enter:13 左37上38右39下40
onfocus事件:当输入框获取焦点的时候
onblue事件:当输入框失去焦点的时候
如果让整个页面绑定按键(onkeydown/onkeyup)

window事件(窗口事件)：onload onresize onscroll
鼠标事件：onclick ondblclick(双击) oncontextmenu(右键菜单)
onmousedown onmouseup onmousemove onmouseenter onmouseleave
键盘事件：onkeydown onkeyup onkeypress(按下并松开)
onkeyup和onkeypress区别：
onkeypress箭头和功能键不能使用,只能是字母和数字键
表单事件：onblur(失去焦点) onchange onfocus onsubmit onreset
onselect(选中时)(input、textarea)
添加事件监听：
obj. addEventListener(event,listener,useCapture)
优点:(1)给同一事件绑定多个处理程序
(2)根据需要可删除
obj. addEventListener("click",function(){},false)
参数event： 事件类型（event不用加on）
参数listener： 事件触发时需要调用的函数或函数名
参数useCapture： 是否在捕获阶段触发事件处理程序(bool类型)。
false表示在冒泡阶段获取事件(由里向外)，
true表示在捕获阶段获取事件(由外向里)。

(1)addEventListener:  this 为注册事件处理程序的dom对象
(2)attachEvent：this 为全局window对象 
call()方法作用:改变函数中this指向
function  addEvent(target,type,handler){ 
if  ( target.addEventListener ){ 
                         target.addEventListener(type,handler,false); 
              }else{ 
                        target.attachEvent("on"+type,function( ){ 
        handler.call(target) }); 
               } 
}

通常情况下，返回值false的话就是阻止浏览器执行该事件相关的默认操作
(a 标签, 提交按钮)
例如：表单提交按钮的onclick事件处理程序返回false的话可以阻止浏览器提交表单

DOM 2.0模型将事件处理分为三个阶段：
1.事件捕获阶段
触发时,顶层对象document就睡发出一个事件流,随DOM树...
2.事件目标阶段
3.事件气泡(冒泡)阶段
如果想阻止事件冒泡：(参考实例0145)
  现代浏览器:e.stopPropagation();
  ie浏览器:e.cancelBubble=true;
  兼容写法:
function(e){
var e = e || event;
if(e.stopPropagation){
e.stopPropagation();
}else{
e.cancelBubble = true;
}
}
onmouseover:支持子元素冒泡
onmouseenter:阻止子元素冒泡
call()和apply：
  相同点:都起到调用函数的作用，并在调用时改变this指向
  不同点:call()接收参数列表,apply()必须把参数放在数组中
  例:var arr=[1,2,3,4,5] 求数组中的最小值
     console.log(Math.min.apply(null,arr));

    改变元素的样式
<div id="box1"></div>
var box1=document.getElementById("box1");
function changeStyle(color,fontSize){
console.log(this);
this.style.color=color;
this.style.fontSize=fontSize+"px";
}
changeStyle.call(box1,"yellow",80);

事件委托(事件处理)(参考实例0146)
可以将事件添加到他们的父节点而将事件委托给父节点来触发处理函数
主要得益于浏览器的事件冒泡机制
优点:1.管理的函数少了2.方便动态添加和修改元素
3.JS和DOM节点的关联少了
阻止浏览器的默认行为：
(1)超链接(2)提交按钮
e.preventDefault(); ie8以外的浏览器
event.returnValue=false; IE7,8
e.preventDefault() || e.returnValue = false;
==jSON{参考示例0147 0148}
javascript对象表示法(javascript Object Notation);
轻量级的文本数据交换方式;
使用javascript语法来描述数据对象,但是json仍然独立于语言和平台;
JSON解析器和json库支持许多不同编程语言(PHP,JSP,.NET)
作用:1.用于存储和传输数据的格式2.通常用于服务器端向网页传输数据
语法规则:1.数据为键/值对2.数据由逗号分隔3.大括号保存对象4.方括号保存数组
json存储的值:数字,字符串,逻辑值,数组,对象,null {即所有的数据类型}
键:加不加双引号都可{字符串}{特殊的键位数字}
json对象没有length属性
遍历:有几个就循环几次
for...in语法格式:for (var x in 对象) {}
x代表每一个键名
JSON字符串:(一旦去掉双引号就能成为JSON对象的字符串)
 注:var str="{name:xixi,age:18}" console.log(str.age) underfined
JSON字符串转JSON对象:evel()和JSON.parse()
注:很少使用eval();仅作了解即可,去双引号
eval();: 外双内单 eval("("+ str +")")
JSON.parse();:外单内双 {str的数据都要双引号}
JSON对象转JSON字符串:JSON.stringify();
ie7下的兼容:在使用之前引入json2.js
--JavaScript 错误 - Throw、Try 和 Catch、finally{参考实例0150}
throw 语句创建自定义错误
try { 
if(x==null)    throw "demo为空，没有正常得到";
//在这里运行代码
}catch(err) { 
//在这里处理错误
}finally{  //无论是否有异常，都要执行的代码
        console.log('ok');
}

//函数的arguments属性:{参考实例0152}
function fun(a,b){
console.log(arguments);//Arguments { 0: 1, 1: 3, 2: 5, 3: 7, 4: 9, 5: 11, 等 2 项… }

console.log(arguments[2]);//5
console.log(arguments.length);//6 实参的个数
console.log(arguments instanceof Array);//flase
}
fun(1,3,5,7,9,11);
arguments对象时一个比较特别的对象,arguments非常类似Array,但实际上不是Array{考点!}

function fun(a,b,c){
console.log(a+b+c);
}
console.log(fun.length);//3---fun形参的个数

**构建不确定参数的函数{参考实例0151}
function fnAdd(){
if(arguments.length == 0){
return;
}else if(arguments.length == 1){

return arguments[0] + 6;
}else{var num = 0;
for(var i=0;i<arguments.length;i++){

num += arguments[i];
}
return num;
}
}

console.log(fnAdd() + "<br>");   //underfined
console.log(fnAdd(1) + "<br>");   //7
console.log(fnAdd(1,2) + "<br>");//3
console.log(fnAdd(1,2,3,4) + "<br>");  //10

==自运行函数:
  作用:隔离作用域
(function(){})();
!function(){}();
  示例: !function(a,b){alert(a+b);}(3,4);
自定义对象:(三种)
//第一种方式 new Object
var age;
var dog = new Object();
dog.name = "huahua";
dog.age = 6;
dog.say = function(){console.log("hello");};

age = 5;
console.log(age); //5
console.log(dog.name); //huahua
dog.say(); //hello

//第二种方式 创建json对象
var person = {};
person.name = "Ali";
person.age = 18;
person.say = function(){console.log("world")};

console.log(person.name);//Ali
person.say();  //world
//第三种方式 构造函数
function Person(name,age){
this.name = name;
this.age = age;
this.say = function(){console.log("hello world")};
}
var pe1 = new Person("张三","18");
var pe2 = new Person("李四","18");
pe1.say();//hello world
pe2.say();//hello world
总结:方式1,2不能复用
构造函数中的this:指的是new出来的实例化对象,而不是构造函数自己
new一个新实例的过程经历了哪些阶段:
(1)创建了空对象 new Object();
(2)等价于用call()调用Person同时把空对象作为this传入
{this代表刚刚创建的空对象}
(3)返回新对象

构造函数和普通函数的区别:
(1)不需要用new关键字调用
(2)可以用return语句返回值
(3)构造函数内的公有属性,公有方法都必须用this指向
(4)函数命名以驼峰格式,而构造函数首字母大写

构建自己的对象,然后调用call()方法继承别人对象中的属性和方法

原型对象prototype也可实现对象的继承
1、所有的构造函数，原生的具有prototype属性

2、所有的构造函数，原生的具有一个实例化对象，而prototype属性指向该对象，所以该对象又称为prototype对象或原型对象。

3、prototype对象，原生的具有两个属性： constructor, _proto_

4、由构造函数new出来的新实例和prototype对象的区别：

共同点： 都是构造函数的实例化对象，都有_proto_属性

不同点： 

（1）prototype对象，并不具有构造函数中的属性和方法。而new出来的新实例有。

（2）可以直接向prototype对象中添加公有的属性和方法 

（当需要所有实例的属性值都相同，方向对应的函数都相同，就应该存入prototype对象）

（3）prototype对象的属性和方法，并不会被复制到其它实例化对象中。

（4）所有new出来的实例化对象的_proto_属性指向生成它的构造函数的prototype对象， 

   所以，当实例调用某个属性或方法时，会先从实例自身的存储空间去找，
   如果找不到，会沿着_proto_属性指向的prototype对象去找，如果找到，该方法也能顺利执行。
console.log(Person.prototype.constructor); 指向构造函数本身

深拷贝:拷贝里面每一个值,当新对象的值改变时,老对象不会改变,因为它们没有指向同一个地址
浅拷贝:拷贝的是地址(引用),当新对象的值改变时,老对象也改变,因为他们指向同一个地址

用call()实现的继承,当继承的对象的原型添加新属性时,实例化对象本身并不会继承该属性
用原型对象实现的继承,把原型对象的指向进行了改变,继承的上层对象的原型发生改变,实例化对象也会改变

 原型链：每个实例化对象都具有一个原型链指针_proto_，该指针指向创建它的函数对象的原型对象，而上一层的原型对象的结构依然类似，有自己的原型链指针，指向创建它的函数对象的原型对象。这样利用_proto_一直指向Object的原型对象上，而Object的原型对象用Object._proto_ = null表示原型链的最顶端。这样由一系列_proto_串起来的原型对象就构成了原型链。

如此便 形成了javascript的原型链继承，同时也解释了为什么所有的javascript对象都具有Object的基本方法。

原型继承和call继承的区别：

1、原型继承是靠更改prototype的指向来实现
      call是靠调用需要继承的构造函数，调用过程改变this指向实现的
2、原型继承可以继承父对象原型中的属性和方法
      而call是不可以的
3、原型继承： 继承的属性和方法不在对象内部，而在原型链上
       call是把继承的属性和方法写入对象自身。

全局变量，容易被污染;局部变量: 不能累加;
闭包有三个特性:(1)函数嵌套函数
(2)子函数内部可以引用外部函数的参数和变量
(3) 参数和变量不会被垃圾回收机制回收
function a(){
var a=0;
return function(){
alert(a++);
}
}
var fun=a();
fun();
fun();
fun=null; 可有可无，避免内存泄漏 

内存泄露:已经没用的内存空间,应该被垃圾回收,驻留在内容中
闭包的好处:允许内部函数在全局调用,但又不害怕被全局变量污染
eval()函数可以实现将字符串计算为变量名